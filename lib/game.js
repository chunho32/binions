// Generated by CoffeeScript 1.12.5
(function() {
  var Deck, EventEmitter, Game, Hand, Player, utils,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  Deck = require('hoyle').Deck;

  Hand = require('hoyle').Hand;

  Player = require('./player').Player;

  utils = require('util');

  Game = exports.Game = (function(superClass) {
    extend(Game, superClass);

    Game.STATUS = {
      NORMAL: 0,
      PRIVILEGED: 1
    };

    function Game(players, betting, hand) {
      var i, j, len, player, ref;
      this.hand = hand || 1;
      this.Betting = betting;
      this.players = players.filter(function(p) {
        return p.chips > 0;
      });
      if (this.players.length < 2) {
        throw "Not enough players";
      }
      if (this.players.length > 22) {
        throw "You can't have more that 22 players. I don't have that many cards";
      }
      ref = this.players;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        player = ref[i];
        player.position = i;
      }
      this.state = null;
      this.reset();
    }

    Game.prototype.reset = function() {
      var j, len, player, ref;
      ref = this.players;
      for (j = 0, len = ref.length; j < len; j++) {
        player = ref[j];
        player.reset();
      }
      this.deck = new Deck();
      this.community = [];
      this.burn = [];
      return this.winners = [];
    };

    Game.prototype.run = function() {
      this.emit('roundStart');
      this.deck.shuffle();
      this.deck.once('shuffled', (function(_this) {
        return function() {
          _this.deal();
          return setTimeout(function() {
            return _this.takeBets();
          }, 4000);
        };
      })(this));
      return this.on('roundComplete', (function(_this) {
        return function() {
          if (_this.deal()) {
            return setTimeout(function() {
              return _this.takeBets();
            }, 4000);
          } else {
            return _this.settle();
          }
        };
      })(this));
    };

    Game.prototype.takeBets = function(betting, cb) {
      var betOptions, status;
      betting || (betting = new this.Betting(this.players, this.state));
      betOptions = betting.analyze();
      if (betOptions) {
        status = this.status(Game.STATUS.NORMAL, betting.nextToAct, betOptions);
        this.emit('playerBetStart', betting);
        return betting.nextToAct.update(status, (function(_this) {
          return function(err, res) {
            if (err) {
              _this.emit("bettingError", err, betting.nextToAct);
            }
            betting.bet(res || 0, null, err);
            return _this.takeBets(betting);
          };
        })(this));
      } else {
        this.emit("roundComplete", this.state);
        return typeof cb === "function" ? cb() : void 0;
      }
    };

    Game.prototype.takeBlinds = function() {
      return new this.Betting(this.players, this.state).takeBlinds();
    };

    Game.prototype.deal = function() {
      var retval;
      if (this.activePlayers().length <= 1 && this.state !== null) {
        return false;
      }
      retval = true;
      switch (this.state) {
        case null:
          this.preFlop();
          break;
        case 'pre-flop':
          this.flop();
          break;
        case 'flop':
          this.turn();
          break;
        case 'turn':
          this.river();
          break;
        case 'river':
        case 'final':
          this.state = 'final';
          retval = false;
      }
      this.emit('stateChange', this.state);
      return retval;
    };

    Game.prototype.preFlop = function() {
      var j, k, len, len1, player, ref, ref1, results;
      this.takeBlinds();
      this.state = 'pre-flop';
      ref = this.players;
      for (j = 0, len = ref.length; j < len; j++) {
        player = ref[j];
        player.cards.push(this.deck.deal());
      }
      ref1 = this.players;
      results = [];
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        player = ref1[k];
        results.push(player.cards.push(this.deck.deal()));
      }
      return results;
    };

    Game.prototype.flop = function() {
      this.state = 'flop';
      this.burn.push(this.deck.deal());
      this.community.push(this.deck.deal(), this.deck.deal(), this.deck.deal());
      return true;
    };

    Game.prototype.turn = function() {
      this.state = 'turn';
      this.burn.push(this.deck.deal());
      return this.community.push(this.deck.deal());
    };

    Game.prototype.river = function() {
      this.state = 'river';
      this.burn.push(this.deck.deal());
      return this.community.push(this.deck.deal());
    };

    Game.prototype.status = function(level, player, betOptions) {
      var j, len, playerLevel, ref, s;
      s = {};
      s.community = this.community.map(function(c) {
        return c.toString();
      });
      s.state = this.state;
      s.hand = this.hand;
      s.betting = betOptions || null;
      if (this.winners && this.winners.length > 0) {
        s.winners = this.winners;
      }
      if (level === Game.STATUS.PRIVILEGED) {
        s.deck = this.deck;
        s.burn = this.burn;
      }
      if (player) {
        s.self = player.status(Player.STATUS.PRIVILEGED);
        s.self.position = this.players.indexOf(player);
      }
      s.players = [];
      ref = this.players;
      for (j = 0, len = ref.length; j < len; j++) {
        player = ref[j];
        playerLevel = this.state === 'complete' ? Player.STATUS.FINAL : Player.STATUS.PUBLIC;
        if (level === Game.STATUS.PRIVILEGED) {
          playerLevel = Player.STATUS.PRIVILEGED;
        }
        s.players.push(player.status(playerLevel));
      }
      return s;
    };

    Game.prototype.distributeWinnings = function(winners) {
      if (winners.length > 1) {
        return this.splitPot(winners);
      } else {
        return this.payout(winners[0], this.take(winners[0].wagered));
      }
    };

    Game.prototype.splitPot = function(winners) {
      var each, i, j, leftover, len, lowest, results, total, winner;
      lowest = Math.min.apply(Math, winners.map(function(w) {
        return w.wagered;
      }));
      total = this.take(lowest);
      each = Math.floor(total / winners.length);
      leftover = total - each * winners.length;
      results = [];
      for (i = j = 0, len = winners.length; j < len; i = ++j) {
        winner = winners[i];
        if (i === 0) {
          results.push(this.payout(winner, each + leftover));
        } else {
          results.push(this.payout(winner, each));
        }
      }
      return results;
    };

    Game.prototype.take = function(amount) {
      var j, len, player, ref, total;
      total = 0;
      ref = this.players;
      for (j = 0, len = ref.length; j < len; j++) {
        player = ref[j];
        if (amount > player.wagered) {
          total = total + player.wagered;
          player.payout = player.payout - player.wagered;
          player.wagered = 0;
        } else {
          total = total + amount;
          player.payout = player.payout - amount;
          player.wagered = player.wagered - amount;
        }
      }
      return total;
    };

    Game.prototype.payout = function(winner, amount) {
      this.winners.push({
        position: winner.position,
        amount: amount
      });
      winner.payout = winner.payout + amount;
      return winner.chips = amount + winner.chips;
    };

    Game.prototype.pot = function() {
      var j, len, player, ref, t;
      t = 0;
      ref = this.players;
      for (j = 0, len = ref.length; j < len; j++) {
        player = ref[j];
        t = t + player.wagered;
      }
      return t;
    };

    Game.prototype.activePlayers = function() {
      var calls;
      calls = this.players.filter(function(p) {
        return p.inPlay();
      });
      return calls;
    };

    Game.prototype.notifyPlayers = function(callback, index) {
      var player;
      index || (index = 0);
      player = this.players[index];
      if (player) {
        return player.update(this.status(Game.STATUS.FINAL, player), (function(_this) {
          return function() {
            return _this.notifyPlayers(callback, index + 1);
          };
        })(this));
      } else {
        return callback();
      }
    };

    Game.prototype.settle = function() {
      var hands, inPlay, winners, winningHands;
      this.state = 'complete';
      inPlay = this.activePlayers();
      while (inPlay.length >= 1) {
        if (inPlay.length === 1) {
          this.distributeWinnings(inPlay);
          break;
        } else {
          hands = inPlay.map((function(_this) {
            return function(p) {
              return p.makeHand(_this.community);
            };
          })(this));
          winningHands = Hand.pickWinners(hands);
          winners = inPlay.filter(function(p) {
            return winningHands.indexOf(p.hand) >= 0;
          });
          this.distributeWinnings(winners);
          inPlay = this.activePlayers();
        }
      }
      return this.notifyPlayers((function(_this) {
        return function() {
          return _this.emit('complete');
        };
      })(this));
    };

    return Game;

  })(EventEmitter);

}).call(this);
